
:toc:
:toclevels: 4

= Picky Certificate Authority

This document covers the design principles and protocol specification of the Picky Certificate Authority.

== Related Specifications

https://github.com/multiformats/multihash[Multihash format]

https://github.com/multiformats/multibase[Multibase format]

https://tools.ietf.org/html/draft-cavage-http-signatures-12[HTTP signatures]

https://tools.ietf.org/html/rfc4158[RFC4158: Internet X.509 Public Key Infrastructure: Certification Path Building]

https://tools.ietf.org/html/rfc7468[RFC7468: Textual Encodings of PKIX, PKCS, and CMS Structures]

=== Other Inspiration

The following specifications are not used in directly in picky, but are sources of inspiration for its design:

https://tools.ietf.org/html/rfc7093[RFC7093: Additional Methods for Generating Key Identifiers Values]

https://tools.ietf.org/html/rfc2585[RFC2585: Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP]

https://tools.ietf.org/html/rfc4387[RFC4387: Internet X.509 Public Key Infrastructure Operational Protocols: Certificate Store Access via HTTP]

https://tools.ietf.org/html/rfc4043[RFC4043: Internet X.509 Public Key Infrastructure Permanent Identifier]

https://tools.ietf.org/html/rfc8649[RFC8649: Hash Of Root Key Certificate Extension]

== Certificate Addressing

Taking inspiration from https://ipfs.io/[IPFS], picky uses content addressing to refer to X.509 certificates. In this case, it means that we refer to an X.509 certificate by the hash of its binary representation (ASN.1 DER). The content address is a multibase-encoded multihash, where base64url encoding and SHA256 hashing are used by default. The result is a concise, self-descriptive string that is adaptable to multiple hash types and base encodings without ambiguity.

For instance, let's take the SHA256 hash of the string "multihash" (without a newline character):

----
echo -n "multihash" | sha256sum
9cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe47
----

The resulting hexadecimal string contains the 32 bytes of the SHA256 hash. To convert it to a https://github.com/multiformats/multihash[multihash], we prefix it with the hash type (0x12) and length (0x20):

----
12209cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe47
----

This hexadecimal string can then be converted to base64url, which is much shorter while remaining URL safe:

----
EiCcvAfD-ZFyWDajqipYHKICkZiqQgudmbwOEx2fPiy-Rw
----

The last step is to prefix the base64url string with the character 'u', which is the https://github.com/multiformats/multibase[multibase] code for base64url:

----
uEiCcvAfD-ZFyWDajqipYHKICkZiqQgudmbwOEx2fPiy-Rw
----

The string "uEiCcvAfD-ZFyWDajqipYHKICkZiqQgudmbwOEx2fPiy-Rw" becomes our content address for the string content "multihash".

In the case of X.509 certificates, the same process is used on the binary representation of the certificate (ASN.1 DER) to obtain the corresponding content address. This means that even if the certificate is stored or transmitted in base64 or PEM format, the hash is always done on the corresponding binary data and not the textual representation.

== Certificate Storage

All X.509 certificates are stored in a flat key-value store where the key is the content address and the value is the X.509 certificate in binary representation. Textual representations such as base64 or PEM should be handled with on-the-fly conversions to and from the binary representation.

The key-value store can be an in-memory hash map, local files, a database like MongoDB or a distributed cache like Redis. X.509 certificates should be stored only in one place to then use the content address as a reference in other tables without duplicating the content.

Regardless of the storage backend, what matters is that it uses the content address as the key, and that it should be easy to check that the stored content matches the content address. Since the content address is computed over the binary representation of the certificate, storing certificates in ASN.1 DER binary format is recommended.

== Certificate Caching

Because all X.509 certificates are content-addressed, they can be easily cached on both the client and server. Leaf certificates can be cached on the server for the purpose of making them available to other peers. Because of its immutable nature, content-addressed certificates do not need to be invalidated in potential HTTP caching proxies. The contents of a certificate fetched using the content address will never change.

However, a configurable expiration time should be put on the server certificate cache to avoid caching old certificates that are no longer in use. This expiration time is only used to remove entries from the cache and has nothing to do with the certificate validity period.

When leaf certificate caching is enabled, new certificates should automatically be cached after they've been signed by the certificate authority. Existing leaf certificates can be pushed back to the server to ensure they are still available in the cache for a period of time, resetting cache expiration time.

The trade-off of removing certificates after a certain period of time but allowing them to be pushed back in the cache ensures that we store only certificates that are in use while being able to function with certificates that were emitted some time ago.
